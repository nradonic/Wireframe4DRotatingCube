<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Wireframe Cube</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        
        #canvas {
            border: 2px solid #333;
            background: radial-gradient(circle at center, #001122, #000000);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 600px;
        }
        
        .scale-control {
            grid-column: 1 / -1;
            justify-self: center;
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 50, 50, 0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #004444;
        }
        
        .slider-group label {
            margin-bottom: 10px;
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff88;
        }
        
        .slider {
            width: 200px;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #00ff88;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px #00ff88;
        }
        
        .value-display {
            margin-top: 8px;
            font-size: 12px;
            color: #88ffaa;
        }
        
        .info {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>4D Wireframe Tesseract</h1>
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <div class="controls">
        <div class="slider-group scale-control">
            <label for="scale">Scale</label>
            <input type="range" id="scale" class="slider" min="0.2" max="2.0" step="0.05" value="1.0">
            <div class="value-display" id="valScale">1.00</div>
        </div>
        
        <div class="slider-group">
            <label for="rotXY">XY Rotation Rate</label>
            <input type="range" id="rotXY" class="slider" min="-1" max="1" step="0.01" value="0.3">
            <div class="value-display" id="valXY">0.30</div>
        </div>
        
        <div class="slider-group">
            <label for="rotXZ">XZ Rotation Rate</label>
            <input type="range" id="rotXZ" class="slider" min="-1" max="1" step="0.01" value="0.2">
            <div class="value-display" id="valXZ">0.20</div>
        </div>
        
        <div class="slider-group">
            <label for="rotXW">XW Rotation Rate</label>
            <input type="range" id="rotXW" class="slider" min="-1" max="1" step="0.01" value="0.1">
            <div class="value-display" id="valXW">0.10</div>
        </div>
        
        <div class="slider-group">
            <label for="rotYZ">YZ Rotation Rate</label>
            <input type="range" id="rotYZ" class="slider" min="-1" max="1" step="0.01" value="0.15">
            <div class="value-display" id="valYZ">0.15</div>
        </div>
    </div>
    
    <div class="info">
        <p>4D hypercube projected to 2D â€¢ Control rotation rates around each axis pair</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // 4D tesseract vertices (16 vertices)
        const vertices4D = [
            [-1, -1, -1, -1], [1, -1, -1, -1], [1, 1, -1, -1], [-1, 1, -1, -1],
            [-1, -1, 1, -1], [1, -1, 1, -1], [1, 1, 1, -1], [-1, 1, 1, -1],
            [-1, -1, -1, 1], [1, -1, -1, 1], [1, 1, -1, 1], [-1, 1, -1, 1],
            [-1, -1, 1, 1], [1, -1, 1, 1], [1, 1, 1, 1], [-1, 1, 1, 1]
        ];
        
        // Tesseract edges (32 edges)
        const edges = [
            // Inner cube (w = -1)
            [0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4],
            [0,4], [1,5], [2,6], [3,7],
            // Outer cube (w = 1)
            [8,9], [9,10], [10,11], [11,8], [12,13], [13,14], [14,15], [15,12],
            [8,12], [9,13], [10,14], [11,15],
            // Connections between cubes
            [0,8], [1,9], [2,10], [3,11], [4,12], [5,13], [6,14], [7,15]
        ];
        
        let rotationRates = {
            xy: 0.3,
            xz: 0.2,
            xw: 0.1,
            yz: 0.15
        };
        
        let scale = 1.0;
        
        let time = 0;
        
        // Rotation matrices for 4D
        function rotateXY(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                [c, -s, 0, 0],
                [s, c, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];
        }
        
        function rotateXZ(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                [c, 0, -s, 0],
                [0, 1, 0, 0],
                [s, 0, c, 0],
                [0, 0, 0, 1]
            ];
        }
        
        function rotateXW(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                [c, 0, 0, -s],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [s, 0, 0, c]
            ];
        }
        
        function rotateYZ(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [
                [1, 0, 0, 0],
                [0, c, -s, 0],
                [0, s, c, 0],
                [0, 0, 0, 1]
            ];
        }
        
        function multiplyMatrix4D(a, b) {
            const result = Array(4).fill().map(() => Array(4).fill(0));
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    for (let k = 0; k < 4; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            return result;
        }
        
        function transformVertex(vertex, matrix) {
            return [
                vertex[0] * matrix[0][0] + vertex[1] * matrix[0][1] + vertex[2] * matrix[0][2] + vertex[3] * matrix[0][3],
                vertex[0] * matrix[1][0] + vertex[1] * matrix[1][1] + vertex[2] * matrix[1][2] + vertex[3] * matrix[1][3],
                vertex[0] * matrix[2][0] + vertex[1] * matrix[2][1] + vertex[2] * matrix[2][2] + vertex[3] * matrix[2][3],
                vertex[0] * matrix[3][0] + vertex[1] * matrix[3][1] + vertex[2] * matrix[3][2] + vertex[3] * matrix[3][3]
            ];
        }
        
        function project4Dto2D(vertex4D) {
            // 4D to 3D projection
            const distance = 2;
            const w = vertex4D[3];
            const scale3D = distance / (distance + w);
            const x3D = vertex4D[0] * scale3D;
            const y3D = vertex4D[1] * scale3D;
            const z3D = vertex4D[2] * scale3D;
            
            // 3D to 2D projection with user-controlled scaling
            const perspective = 400;
            const scale2D = perspective / (perspective + z3D);
            
            return {
                x: centerX + x3D * scale2D * 100 * scale,
                y: centerY + y3D * scale2D * 100 * scale,
                depth: z3D + w * 0.5
            };
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create combined rotation matrix
            let rotMatrix = rotateXY(time * rotationRates.xy);
            rotMatrix = multiplyMatrix4D(rotMatrix, rotateXZ(time * rotationRates.xz));
            rotMatrix = multiplyMatrix4D(rotMatrix, rotateXW(time * rotationRates.xw));
            rotMatrix = multiplyMatrix4D(rotMatrix, rotateYZ(time * rotationRates.yz));
            
            // Transform vertices
            const transformedVertices = vertices4D.map(vertex => transformVertex(vertex, rotMatrix));
            const projectedVertices = transformedVertices.map(vertex => project4Dto2D(vertex));
            
            // Draw edges
            edges.forEach(edge => {
                const v1 = projectedVertices[edge[0]];
                const v2 = projectedVertices[edge[1]];
                
                // Color based on depth
                const avgDepth = (v1.depth + v2.depth) / 2;
                const intensity = Math.max(0.2, Math.min(1, (avgDepth + 2) / 4));
                const alpha = Math.max(0.3, Math.min(1, intensity));
                
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.strokeStyle = `rgba(0, ${Math.floor(255 * intensity)}, ${Math.floor(136 * intensity)}, ${alpha})`;
                ctx.lineWidth = 3 + intensity;
                ctx.stroke();
            });
            
            // Draw vertices
            projectedVertices.forEach((vertex, i) => {
                const intensity = Math.max(0.3, Math.min(1, (vertex.depth + 2) / 4));
                const radius = 2 + intensity * 2;
                
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, ${Math.floor(255 * intensity)}, ${Math.floor(136 * intensity)}, 0.8)`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.5})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            time += 0.02;
            requestAnimationFrame(animate);
        }
        
        // Set up slider controls
        const sliders = {
            scale: document.getElementById('scale'),
            rotXY: document.getElementById('rotXY'),
            rotXZ: document.getElementById('rotXZ'),
            rotXW: document.getElementById('rotXW'),
            rotYZ: document.getElementById('rotYZ')
        };
        
        const valueDisplays = {
            scale: document.getElementById('valScale'),
            rotXY: document.getElementById('valXY'),
            rotXZ: document.getElementById('valXZ'),
            rotXW: document.getElementById('valXW'),
            rotYZ: document.getElementById('valYZ')
        };
        
        // Scale slider
        sliders.scale.addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            valueDisplays.scale.textContent = scale.toFixed(2);
        });
        
        // Scale slider double-click reset
        sliders.scale.addEventListener('dblclick', () => {
            sliders.scale.value = 1.0;
            scale = 1.0;
            valueDisplays.scale.textContent = '1.00';
        });
        
        // Rotation sliders
        Object.keys(sliders).forEach(key => {
            if (key !== 'scale') {
                sliders[key].addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    rotationRates[key.replace('rot', '').toLowerCase()] = value;
                    valueDisplays[key].textContent = value.toFixed(2);
                });
                
                // Double-click reset to 0 for rotation sliders
                sliders[key].addEventListener('dblclick', () => {
                    sliders[key].value = 0;
                    rotationRates[key.replace('rot', '').toLowerCase()] = 0;
                    valueDisplays[key].textContent = '0.00';
                });
            }
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>